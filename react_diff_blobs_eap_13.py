# -*- coding: utf-8 -*-
"""
Created on Mon Apr 20 17:11:30 2020

@author: pkiuru

Script file for transient production-diffusion simulation for O2, CO2, 13-CO2
and 13-CH4.

Required input:
    OpenPNM network object (.pnm file; generated by samp_an_100.py)
    Alternatively, the simulation can be run using a network with approximately
    cylindrical shape and cubical cells (pores) by switching cubic_pore = True

"""

import openpnm as op
import numpy as np
import matplotlib.pyplot as plt
import my_models
import time
import pdb
import warnings
warnings.filterwarnings("ignore", category=FutureWarning)

from matplotlib import rcParams
rcParams['figure.max_open_warning'] = 40
rcParams['font.size'] = 8

# Pore networks from the 100-um-voxel-size images

if False:

    ws = op.Workspace()
    ws.clear()
    ws.load_workspace(filename='D:/network_6A_130_970.pnm', overwrite=True)
    
    #Trimmed, i.e., connected network
    proj = ws['full_image']
    pn = proj['net_01']
    geom = proj['geo_01']
    
    # Set the boundary to the atmosphere
    Ps_front = pn['pore.left']
    
    #Set the volumes of the boundary pores to 0
    pn['pore.volume'][pn['pore.boundary']] = 0.
    
    #Approximate total sample volume (m3)
    vol_sample = (np.max(pn['pore.coords'][:,0]) * np.max(pn['pore.coords'][:,1])
                  * np.max(pn['pore.coords'][:,2]) * np.pi/4)
    
    '''
    voxel_size = 100e-6
    height = 830
    width = 910
    caf_real = np.pi/4
    vol_sample = caf_real*height*width**2*voxel_size**3
    '''
    
# OLD PEAT uCT IMAGE (50 um voxel size)

if False:
        
    no_boundary = 0
    
    ws = op.Workspace()
    ws.clear()
    #ws.load_workspace(filename='C:/Users/pkiuru/Pictures/metnet_ct_reco/0_5_2_600.pnmm', overwrite=True)
    ws.load_workspace(filename='C:/Users/pkiuru/Pictures/metnet_ct_reco/0_5_3_600.pnmm', overwrite=True)
    #Trimmed, i.e., connected network
    proj = ws['image']
    pn = proj['net_01']
    geom = proj['geo_01']
    #geom = op.geometry.GenericGeometry(network=pn, pores=pn.Ps, throats=pn.Ts)
    if no_boundary:
       op.topotools.trim(pn, pores = pn['pore.boundary'])

    #Kavennetaan verkkoa 1. ja 2. akselin suunnissa
    '''
    mean_1 = np.mean(pn['pore.coords'][:,1])
    trimmed_1 = pn['pore.coords'][:,1] > mean_1 * 0.75
    op.topotools.trim(pn, pores = trimmed_1)
    mean_2 = np.mean(pn['pore.coords'][:,2])
    trimmed_2 = pn['pore.coords'][:,2] > mean_2 * 1
    op.topotools.trim(pn, pores = trimmed_2)
    '''
    '''
    #Vastaavasti kavennetaan vielä näinkin päin.
    
    mean_0 = np.mean(pn['pore.coords'][:,0])
    trimmed_0 = pn['pore.coords'][:,0] > mean_0 * 1
    op.topotools.trim(pn, pores = trimmed_0)
    
    hech = pn.check_network_health()
    op.topotools.trim(pn, pores = hech['trim_pores'])
    '''
    # <- Mutta sitten taas pnum-määritys, jota tarvitaan akselin koon määritykseen, ei toimi...
    
    #Tämä vaaditaan, jotta reunahuokosten tilavuudeksi voidaan asettaa 0. Muuten 
    #isoloidut reunahuokoset rikkovat laskennan.
    op.topotools.trim(pn, pores = pn.check_network_health()['trim_pores'])
    
    pn['pore.volume'][pn['pore.boundary']] = 0.
    
    Ps_border = np.absolute(pn['pore.coords'][:,0])  > 0.030#0.0055
    #pnum = np.sum(np.absolute(pn['pore.coords'][:,0])  > 0.95*mean_0)

    xdim = 0.03
    pnum = np.sum(Ps_border)
    hilavali = xdim/pnum
    
    #3D-kuva
    if no_boundary:
        Ps_front = np.absolute(pn['pore.coords'][:,0])  < 0.0005#0.0055
    else:
        # pore.left in uCT networks <-> z = 0
        Ps_front = pn['pore.left']
    
    #Lasketaan, kuinka monta kytköstä kullakin huokosella on    
    connections_all = np.zeros(pn.Np)    
    for j, k in enumerate(pn['throat.conns']):
        if pn['pore.all'][pn['throat.conns'][j,1]]:
            connections_all[pn['throat.conns'][j,0]] += 1
            connections_all[pn['throat.conns'][j,1]] += 1
            

# Cubic grid: corresponds to an ordinary finite elemet method calculation
# Cubic elements, approximately cylindrical 3D shape

cubic_pore = True

if cubic_pore:
    
    from utils_cubic import extract_cyl, find_center
    
    ws = op.Workspace()
    ws.clear()
    
    spacing = 1e-2 # cell size (m)
    L_OP = 0.10 # Total cylinder length (m)
    D_OP = 0.09 # Cylinder diameter (m)
    Nx = np.int(L_OP/spacing)
    Nd = np.int(D_OP/spacing)
    shape = [Nx, Nd, Nd]
        
    pn = op.network.Cubic(shape=shape, spacing=spacing)
    
    #Artificial boundary pores to the top surface
    pn.add_boundary_pores(labels=['front'], spacing=0.0)
    
    #Trim the network domain to a cylindrical shape
    op.topotools.trim(network=pn, pores=extract_cyl(pn,Nd,spacing))
    
    #Index of the pore nearest the center of the network
    center = find_center(pn,Nd,spacing)
    
    l = pn['pore.coords'][pn['pore.internal'], 0].max() - pn['pore.coords'][pn['pore.internal'], 0].min()
    print(l)
    
    geom = op.geometry.GenericGeometry(network=pn, pores=pn.Ps, throats=pn.Ts)
    geom['pore.diameter'] = spacing
    geom['throat.diameter'] = spacing
    geom['throat.length'] = spacing
    geom['throat.area'] = (spacing)**2
    geom['pore.area'] = (spacing)**2
    geom['pore.volume'] = geom['pore.area']*spacing
    geom['throat.volume'] = 0.0
    
    geom['throat.length'][~pn['throat.internal']] = 0.5*spacing
    geom['pore.volume'][~pn['pore.internal']] = geom['pore.area'][~pn['pore.internal']]*spacing * 0.0
    
    geom.add_model(propname='throat.endpoints', model=op.models.geometry.throat_endpoints.spherical_pores,
                  pore_diameter='pore.diameter', throat_diameter='throat.diameter')
    geom.add_model(propname='throat.conduit_lengths', model=op.models.geometry.throat_length.conduit_lengths)
    
    pn['pore.volume'][~pn['pore.internal']] = 0.
    
    Ps_front = pn['pore.front_boundary']
    
    #Total sample volume (m3)
    vol_sample = np.sum(pn['pore.volume'])
  
#------------------------------------------------------------------------------
# END OF NETWORK IMPORT/GENERATION
#------------------------------------------------------------------------------

vols = pn['pore.volume']

#Creation of phases and their physics

# Methane

air = op.phases.Air(network=pn)

phys_air = op.physics.Standard(network=pn, phase=air, geometry=geom)

air.remove_model('pore.diffusivity')
air['pore.diffusivity'] = 2.10e-5
if cubic_pore:
    air['pore.diffusivity'] *= 0.005
air.regenerate_models()
phys_air.regenerate_models()
mod = op.models.physics.diffusive_conductance.ordinary_diffusion

phys_air.add_model(propname='throat.diffusive_conductance', model=mod, regen_mode='normal')

phys_air.regenerate_models()

#----------------------------------------------------
# Carbon dioxide

co2 = op.phases.Air(network=pn)

phys_co2 = op.physics.Standard(network=pn, phase=co2, geometry=geom)

co2.remove_model('pore.diffusivity')
co2['pore.diffusivity'] = 1.60e-5
if cubic_pore:
    co2['pore.diffusivity'] *= 0.005
co2.regenerate_models()
phys_co2.regenerate_models()
mod = op.models.physics.diffusive_conductance.ordinary_diffusion

phys_co2.add_model(propname='throat.diffusive_conductance', model=mod, regen_mode='normal')

phys_co2.regenerate_models()


# 13C carbon dioxide

co13 = op.phases.Air(network=pn)

phys_co13 = op.physics.Standard(network=pn, phase=co13, geometry=geom)

co13.remove_model('pore.diffusivity')
co13['pore.diffusivity'] = 1.60e-5
if cubic_pore:
    co13['pore.diffusivity'] *= 0.005
co13.regenerate_models()
phys_co13.regenerate_models()
mod = op.models.physics.diffusive_conductance.ordinary_diffusion

phys_co13.add_model(propname='throat.diffusive_conductance', model=mod, regen_mode='normal')

phys_co13.regenerate_models()

# Oxygen

o2 = op.phases.Air(network=pn)

phys_o2 = op.physics.Standard(network=pn, phase=o2, geometry=geom)

o2.remove_model('pore.diffusivity')
o2['pore.diffusivity'] = 2.02e-5
if cubic_pore:
    o2['pore.diffusivity'] *= 0.005
o2.regenerate_models()
phys_o2.regenerate_models()
mod = op.models.physics.diffusive_conductance.ordinary_diffusion

phys_o2.add_model(propname='throat.diffusive_conductance', model=mod, regen_mode='normal')

phys_o2.regenerate_models()

#-------------------------------------------------

# Simulation time

boundcon = 1

sch = 2
if sch == 1:
    t_scheme = 'cranknicolson'
else:
    t_scheme = 'implicit'

# The simulation proceeds one step at a time 

initialt = 0
finalt = 0.1 * 100 # step length (s)
stept = finalt
time_counter = initialt
counter_max = 1000 # number of steps

#In long simulations, the size of some of the results  can be restricted for convenience
nothinning = False 
thinning_factor = 50

print('Time step', stept, 's, simulation period', counter_max * stept, 's')

#------------------------------------------------------------------------------

#Choose pores in which the 13C generation occurs

#Relative vertical coordinates of the pores
vert_posit = pn['pore.coords'][:,0]/np.max(pn['pore.coords'][:,0])
    
Ps_middle_meth = np.logical_and(vert_posit > 0.60,vert_posit < 0.725 )
#Ps_middle_meth = pn['pore.internal']


air['pore.source.concentration'] = 0.
air['pore.source.concentration'][Ps_middle_meth] = 0.
vols_source = vols[Ps_middle_meth] 

#------------------------------------------------------------------------------
#Initial concentrations (mmol/m3). In dry air, oxygen ~8700, CO2 ~17.

#Methane (mmol m-3)

meth_amb = 0.

air['pore.concentration'] = meth_amb*np.zeros(geom.Np)

air['pore.concentration'][Ps_middle_meth] = 0.

air['pore.concentration_init'] = air['pore.concentration']
 
   
   
#Carbon dioxide (mmol m-3)

co2_amb = 20.
k = 1.#8700/17

co2['pore.concentration'] = k * co2_amb*np.ones(geom.Np)# * vert_posit**2
#co2['pore.concentration'] = co2_amb*np.ones(geom.Np)

co2['pore.concentration_init'] = co2['pore.concentration']


#13C carbon dioxide (mmol m-3)

co13_amb = 0.
k13 = 1.

co13['pore.concentration'] = k13 * co13_amb*np.ones(geom.Np)# * vert_posit**2

co13['pore.concentration_init'] = co13['pore.concentration']

#Oxygen (mmol m-3)

o2_amb = 1.*8700.

o2['pore.concentration'] =  1.* o2_amb*np.ones(geom.Np)# * (1 - vert_posit**2)
#o2['pore.concentration'] = o2_amb*np.ones(geom.Np)

o2['pore.concentration_init'] = o2['pore.concentration']

#Calculate the initial amount of oxygen and the other gases in the headspace.

#Headspace volume
V_ext = 0.0005 # m3

n_meth_ext = meth_amb * V_ext
n_o2_ext = o2_amb * V_ext
n_co2_ext = co2_amb * V_ext
n_co13_ext = co13_amb * V_ext

#Set the initial amount of "methanogenic" material

n_acet = 20e-3 # mmol
    
#-----------------------------------------------
  
# Parameters for biochemical processes, following the parameters in Himmeli    

#Fraction of methane generation in anaerobic degradation
methane_fraction = 0.5

#Air-filled porosity scaling term for fifferent realization of the parameters
#afp =  0.0833 #4A: 0.0833 4B: 0.074
afp = 1.

# The model for anaerobic degradation is constructed in a more complicated way, using the
# linear model for reaction rate in OpenPNM, but it is just a zeroth-order model
# r = Ax + b where A = 0 and b(source pores) != 0 

#Linear model for the source term
phys_air['pore.srcA'] = 0.
phys_air['pore.srcb'] = 0.
#literature maximum 0.1 mmol m-3 s-1; divided by afp
phys_air['pore.srcb'][Ps_middle_meth] = 0.1 / afp / 2000
phys_air.add_model(propname='pore.source', model=op.models.physics.generic_source_term.linear,
               A1='pore.srcA', A2='pore.srcb', X='pore.source.concentration')

#Model for oxygen restriction factor for respiration
phys_o2['pore.half_sat_constant'] = 20.
phys_o2.add_model(propname='pore.resp_restr_factor', model=my_models.michaelis_menten_respiration,
               half_sat_constant=phys_o2['pore.half_sat_constant'], X='pore.concentration')

#Model for oxygen restriction factor for oxidation
phys_o2['pore.oxid_half_sat_constant'] = 30.
phys_o2.add_model(propname='pore.oxid_restr_factor', model=my_models.michaelis_menten_respiration,
               half_sat_constant=phys_o2['pore.oxid_half_sat_constant'], X='pore.concentration')

#Model for methane restriction factor for oxidation
phys_air['pore.oxid_half_sat_constant'] = 30.
phys_air.add_model(propname='pore.oxid_restr_factor', model=my_models.michaelis_menten_respiration,
               half_sat_constant=phys_air['pore.oxid_half_sat_constant'], X='pore.concentration')

#Model for oxygen inhibition factor for methanogenesis
phys_air['pore.methanogenesis_sensitivity'] = 0.4 * 0.00001
phys_o2.add_model(propname='pore.methanog_inhib_factor', model=my_models.inhibition_factor,
               methanogenesis_sensitivity=phys_air['pore.methanogenesis_sensitivity'], X='pore.concentration')

#Methane oxidation rate
phys_air['pore.methane_oxidation'] = 0.01 / afp
#phys_air['pore.methane_oxidation'][Ps_front] = 0.

#Heterotropic respiration rate
#literature range 0.01...0.03 mmol m-3 s-1 at 20 degrees C (bulk volume)
phys_co2['pore.het_respiration'] = 0.015 / afp  # mmol m-3 s-1 -> divided by air-filled porosity
#phys_co2['pore.het_respiration'][Ps_front] = 0.

#Rate of heterotropic respiration that generates 13CO2
phys_co13['pore.het_respiration'] = 0.
phys_co13['pore.het_respiration'][Ps_middle_meth] = 0.1 / afp  # mmol m-3 s-1 -> divided by air-filled porosity

#--------------------------------------

#Initialize the counters

atm_exch = []

loss_in_diff = np.zeros(counter_max)

amount_change = np.zeros(counter_max)
amount = np.zeros(counter_max)

co2_source_anaer_respiration_sums = np.zeros(counter_max) # -> 13C
generation_sums = np.zeros(counter_max)

meth_oxidation_sums = np.zeros(counter_max)
co2_source_oxidation_sums = np.zeros(counter_max) # -> 13C
h2o_source_oxidation_sums = np.zeros(counter_max)

o2_sink_oxidation_sums = np.zeros(counter_max)
o2_sink_respiration_sums = np.zeros(counter_max)
o2_sink_respiration13_sums = np.zeros(counter_max)

co2_source_respiration_sums = np.zeros(counter_max)

co13_source_respiration_sums = np.zeros(counter_max)

atm_exch_co2 =[]
atm_exch_o2 =[]
atm_exch_co13 =[]

loss_in_diff_co2 = np.zeros(counter_max)
loss_in_diff_o2 = np.zeros(counter_max)
loss_in_diff_co13 = np.zeros(counter_max)

amount_change_co2 = np.zeros(counter_max)
amount_co2 = np.zeros(counter_max)

amount_change_o2 = np.zeros(counter_max)
amount_o2 = np.zeros(counter_max)

amount_change_co13 = np.zeros(counter_max)
amount_co13 = np.zeros(counter_max)

degrading_carbons = np.zeros(counter_max)

n_meth_exts = np.zeros(counter_max)
n_co2_exts = np.zeros(counter_max)
n_o2_exts = np.zeros(counter_max)
n_co13_exts = np.zeros(counter_max)
n_acets = np.zeros(counter_max)

#------------------------------------------------------------------------------
#Start of the time loop
#------------------------------------------------------------------------------

tic2 = time.perf_counter()

printtaus = 0
counter = 0

if nothinning:
    li = [None] * (counter_max + 1)
    li[0] = air['pore.concentration']
else:
    li = []
    li.append(air['pore.concentration'])

while counter < counter_max:
    
    #Counter for total carbon loss
    degrading_carbon = 0. # mmol
    
    conc_0 = air['pore.concentration']
    conc_0_co2 = co2['pore.concentration']
    conc_0_o2 = o2['pore.concentration']
    conc_0_co13 = co13['pore.concentration']
    
    # Now, 13C is generated in anaerobic respiration
    c_old = air['pore.concentration'][Ps_middle_meth]#;print(conc_0[Ps_middle_meth][0:2])
    c_co13_old = co13['pore.concentration']
    
    #Anaerobic degradation
    phys_o2.regenerate_models(propnames='pore.methanog_inhib_factor')
    anaer_gener = phys_o2['pore.methanog_inhib_factor'] * phys_air['pore.source.rate'] * stept
    air['pore.concentration'] = (air['pore.concentration'] + methane_fraction * anaer_gener)
       #phys_o2['pore.methanog_inhib_factor'] * phys_air['pore.source.rate'] * stept)
    co13['pore.concentration'] = (co13['pore.concentration'] + (1 - methane_fraction) * anaer_gener)
    
    #Methane and 13C gain and substrate loss through anaerobic degradation
    conc_re_2 = air['pore.concentration']
    anaer_resp_meth = air['pore.concentration'][Ps_middle_meth] - c_old
    anaer_resp_co2 = co13['pore.concentration'] - c_co13_old
    generation = anaer_resp_meth * vols_source
    co2_source_anaer_respiration = anaer_resp_co2 * vols
    generation_sums[counter] = np.sum(generation)
    co2_source_anaer_respiration_sums[counter] = np.sum(co2_source_anaer_respiration)
    degrading_carbon += (np.sum(anaer_resp_co2 * vols) +
                         np.sum(anaer_resp_meth * vols_source))
    
    
    #Methane oxidation -> now, this generates 13C
    c_old = air['pore.concentration']
    phys_o2.regenerate_models(propnames='pore.oxid_restr_factor')
    phys_air.regenerate_models(propnames='pore.oxid_restr_factor')
    air['pore.concentration'] = np.maximum(air['pore.concentration'] -
       phys_air['pore.oxid_restr_factor'] * phys_o2['pore.oxid_restr_factor'] * phys_air['pore.methane_oxidation'] * stept,0)
    oxid = (air['pore.concentration'] - c_old)
    meth_oxidation = oxid * vols
    meth_oxidation_sums[counter] = np.sum(meth_oxidation)
    
    #CO2(13) gain through methane oxidation (the variable oxid is < 0)
    co13['pore.concentration'] = co13['pore.concentration'] + (-oxid)
    co2_source_oxidation = -oxid * vols
    co2_source_oxidation_sums[counter] = np.sum(co2_source_oxidation)
    
    #O2 loss through methane oxidation
    o2['pore.concentration'] = o2['pore.concentration'] + 2 * oxid
    o2_sink_oxidation = 2*oxid * vols
    o2_sink_oxidation_sums[counter] = np.sum(o2_sink_oxidation)
    h2o_source_oxidation_sums[counter] = np.sum(-2*oxid * vols)
    
    # O2 loss through CO2 generation (heterotrophic respiration)
    c_old = o2['pore.concentration']
    phys_o2.regenerate_models(propnames='pore.resp_restr_factor')
    o2['pore.concentration'] = np.maximum((o2['pore.concentration'] - 
       phys_o2['pore.resp_restr_factor'] * phys_co2['pore.het_respiration'] * stept),0)
    resp = (o2['pore.concentration'] - c_old)
    o2_sink_respiration = resp * vols
    o2_sink_respiration_sums[counter] = np.sum(o2_sink_respiration)
    
    # CO2 generation (heterotrophic respiration)
    co2['pore.concentration'] = co2['pore.concentration'] - resp
    co2_source_respiration = -resp * vols
    co2_source_respiration_sums[counter] = np.sum(co2_source_respiration)
    degrading_carbon += np.sum(-resp * vols)
    
     # O2 loss through CO13 generation (heterotrophic respiration of 13C)
    c_old = o2['pore.concentration']
    phys_o2.regenerate_models(propnames='pore.resp_restr_factor')
    o2['pore.concentration'] = np.maximum((o2['pore.concentration'] - 
       phys_o2['pore.resp_restr_factor'] * phys_co13['pore.het_respiration'] * stept),0)
    resp13 = (o2['pore.concentration'] - c_old)
    o2_sink_respiration13 = resp13 * vols
    o2_sink_respiration13_sums[counter] = np.sum(o2_sink_respiration13)
    
    # CO13 generation (heterotrophic respiration)
    co13['pore.concentration'] = co13['pore.concentration'] - resp13
    co13_source_respiration = -resp13 * vols
    co13_source_respiration_sums[counter] = np.sum(co13_source_respiration)
    degrading_carbon += np.sum(-resp13 * vols)
    
    # Substrate loss in anaerobic degradation
    n_acet_old = np.copy(n_acet)
    n_acet -= (np.sum(generation)+np.sum(co2_source_anaer_respiration)+np.sum(co13_source_respiration))
    if n_acet < 1e-12: 
        n_acet = 0
    n_acets[counter] = n_acet
    
    # The anareobic degradation rate decrases exponentially with the decrease of the
    # amount of substrate
    if n_acet > 0:
        phys_air['pore.srcb'][Ps_middle_meth] = (n_acet / n_acet_old) * phys_air['pore.srcb'][Ps_middle_meth]
        phys_air.regenerate_models(propnames='pore.source')
        phys_co13['pore.het_respiration'] = (n_acet / n_acet_old) * phys_co13['pore.het_respiration']
    else:
        phys_air['pore.srcb'][Ps_middle_meth] = 0.
        phys_air.regenerate_models(propnames='pore.source')
        phys_co13['pore.het_respiration'] = 0.
    
    time_counter = time_counter + stept
    
    if printtaus:
        print([initialt, finalt]); print(counter)
    elif np.logical_and(counter>0,counter % 100 == 0):
        print(counter, 'steps done')
        print('Estimated time left:', np.round((counter_max-counter)/counter*(time.perf_counter()-tic2)), 's')
    
    # Methane diffusion + surface flux
    
    fd_tr = op.algorithms.TransientFickianDiffusion(network=pn, phase=air)
    fd_tr.setup(t_initial=initialt, t_final=finalt, t_step=stept, t_output=stept,
                t_tolerance = 1e-18, rxn_tolerance=1e-12, t_scheme=t_scheme)
    if boundcon:
        fd_tr.set_value_BC(pores=pn.pores()[Ps_front], values=meth_amb)
    fd_tr.set_IC(air['pore.concentration'])
    conc_old = air['pore.concentration']
    fd_tr.run()
    if boundcon:
        flux_here = fd_tr.rate(pores=pn.pores()[Ps_front], mode='single') * stept
        atm_exch.append(flux_here)
    conc_2 = fd_tr['pore.concentration']   
    loss_in_diff[counter] = np.sum(([conc_2 - conc_old]) * vols)

    #------------------------------------------------
    
    # Carbon dioxide diffusion + surface flux
    
    fd_tr_co2 = op.algorithms.TransientFickianDiffusion(network=pn, phase=co2)
    fd_tr_co2.setup(t_initial=initialt, t_final=finalt, t_step=stept, t_output=stept,
                t_tolerance = 1e-18, rxn_tolerance=1e-12, t_scheme=t_scheme)
    if boundcon:
        fd_tr_co2.set_value_BC(pores=pn.pores()[Ps_front], values=co2_amb)
    fd_tr_co2.set_IC(co2['pore.concentration'])
    conc_old = co2['pore.concentration']
    fd_tr_co2.run()
    if boundcon:
        flux_co2 = fd_tr_co2.rate(pores=pn.pores()[Ps_front], mode='single') * stept
        atm_exch_co2.append(flux_co2)
    conc_2_co2 = fd_tr_co2['pore.concentration']
    loss_in_diff_co2[counter] = np.sum(([conc_2_co2 - conc_old]) * vols)
    
    # 13C carbon dioxide diffusion and surface flux
    
    fd_tr_co13 = op.algorithms.TransientFickianDiffusion(network=pn, phase=co13)
    fd_tr_co13.setup(t_initial=initialt, t_final=finalt, t_step=stept, t_output=stept,
                t_tolerance = 1e-18, rxn_tolerance=1e-12, t_scheme=t_scheme)
    if boundcon:
        fd_tr_co13.set_value_BC(pores=pn.pores()[Ps_front], values=co13_amb)
    fd_tr_co13.set_IC(co13['pore.concentration'])
    conc_old = co13['pore.concentration']
    fd_tr_co13.run()
    if boundcon:
        flux_co13 = fd_tr_co13.rate(pores=pn.pores()[Ps_front], mode='single') * stept
        atm_exch_co13.append(flux_co13)
    conc_2_co13 = fd_tr_co13['pore.concentration']
    loss_in_diff_co13[counter] = np.sum(([conc_2_co13 - conc_old]) * vols)
    
    # Oxygen diffusion and surface flux
    
    fd_tr_o2 = op.algorithms.TransientFickianDiffusion(network=pn, phase=o2)
    fd_tr_o2.setup(t_initial=initialt, t_final=finalt, t_step=stept, t_output=stept,
                t_tolerance = 1e-18, rxn_tolerance=1e-12, t_scheme=t_scheme)
    if boundcon:
        fd_tr_o2.set_value_BC(pores=pn.pores()[Ps_front], values=o2_amb)
    fd_tr_o2.set_IC(o2['pore.concentration'])
    conc_old = o2['pore.concentration']
    fd_tr_o2.run()
    if boundcon:
        flux_o2 = fd_tr_o2.rate(pores=pn.pores()[Ps_front], mode='single') * stept
        atm_exch_o2.append(flux_o2)
    conc_2_o2 = fd_tr_o2['pore.concentration']
    loss_in_diff_o2[counter] = np.sum(([conc_2_o2 - conc_old]) * vols)
    
    
    amount_change[counter] = np.sum((conc_2-conc_0) * vols)
    amount[counter] = np.sum(conc_2 * vols)
    
    amount_change_co2[counter] = np.sum((conc_2_co2-conc_0_co2) * vols)
    amount_co2[counter] = np.sum(conc_2_co2 * vols)
    
    amount_change_o2[counter] = np.sum((conc_2_o2-conc_0_o2) * vols)
    amount_o2[counter] = np.sum(conc_2_o2 * vols)
    
    amount_change_co13[counter] = np.sum((conc_2_co13-conc_0_co13) * vols)
    amount_co13[counter] = np.sum(conc_2_co13 * vols)
    
    pn.project.purge_object(fd_tr)
    pn.project.purge_object(fd_tr_co2)
    pn.project.purge_object(fd_tr_o2)
    pn.project.purge_object(fd_tr_co13)
    
    #--------------------------------------------------------------------------    
    

    degrading_carbons[counter] = degrading_carbon
    
    if nothinning:
       li[counter+1] = conc_2
    else:
        if counter % thinning_factor == 0:
            li.append(conc_2)
    
    #Calculate new ambient concentrations -> new boundary conditions
    n_meth_ext -= np.sum(flux_here)
    meth_amb = n_meth_ext / V_ext
    n_meth_exts[counter] = n_meth_ext  
    
    n_co2_ext -= np.sum(flux_co2)
    co2_amb = n_co2_ext / V_ext
    n_co2_exts[counter] = n_co2_ext  
    
    n_o2_ext = n_o2_ext - np.sum(flux_o2)
    o2_amb = np.maximum(n_o2_ext / V_ext, 0)
    n_o2_exts[counter] = n_o2_ext 
    
    n_co13_ext -= np.sum(flux_co13)
    co13_amb = n_co13_ext / V_ext
    n_co13_exts[counter] = n_co13_ext  
    
    counter = counter + 1
    
   
    if(np.any(conc_2_o2<0)):
        break

#------------------------------------------------------------------------------
# End of time loop
#------------------------------------------------------------------------------

if boundcon:
    surfaceflux = np.asarray(atm_exch)
    surfaceflux_sums = np.sum(surfaceflux, axis = 1)    
else:
    surfaceflux = np.zeros([counter , np.sum(Ps_front)])
    surfaceflux_sums = np.zeros([counter])


if boundcon:
    surfaceflux_co2 = np.asarray(atm_exch_co2)
    surfaceflux_o2 = np.asarray(atm_exch_o2)
    surfaceflux_co13 = np.asarray(atm_exch_co13)
    surfaceflux_sums_co2 = np.sum(surfaceflux_co2, axis = 1)
    surfaceflux_sums_o2 = np.sum(surfaceflux_o2, axis = 1)    
    surfaceflux_sums_co13 = np.sum(surfaceflux_co13, axis = 1)    
else:
    surfaceflux_co2 = np.zeros([counter, np.sum(Ps_front)])
    surfaceflux_sums_co2 = np.zeros([counter])
    surfaceflux_o2 = np.zeros([counter, np.sum(Ps_front)])
    surfaceflux_sums_o2 = np.zeros([counter])
    surfaceflux_co13 = np.zeros([counter, np.sum(Ps_front)])
    surfaceflux_sums_co13 = np.zeros([counter])

toc2 = time.perf_counter()
print("Run time:", toc2-tic2, "s")

#------------------------------------------------------------------------------
#------------------------------------------------------------------------------

#Figures

if True:
    
    def draw_2D_prof(target, c, numm, tit):
        
        plt.figure(numm)
        plt.clf()
        factor_fig = 5000
        plt.scatter(target['pore.coords'][:,0], target['pore.coords'][:,1], c=c, s=(factor_fig*target['pore.diameter'])**2, cmap=plt.cm.RdYlGn)
        plt.colorbar()
        plt.title(str(tit))
        x_range = [np.min(target['pore.coords'][:,0]),np.max(target['pore.coords'][:,0])]
        plt.xlim(-0.01*x_range[0], 1.01*x_range[1])
        y_range = [np.min(target['pore.coords'][:,1]),np.max(target['pore.coords'][:,1])]
        plt.ylim(-1.01*y_range[0], 1.01*y_range[1])
        plt.tight_layout()
        
    draw_2D_prof(pn,conc_2, 1,'Methane concentration [mol m-3], sizes w.r.t. pore diameter')
    if len(li) > 10: draw_2D_prof(pn,li[10], 2,'Methane concentration [mol m-3] after 10 saving intervals')
    
    timegrid = stept * np.arange(len(surfaceflux_sums))
    
    plt.figure(num=4,figsize=[11, 6])
    plt.clf()
    plt.subplot(2, 2, 1)
    plt.plot(timegrid, 1e9*amount_change, label ='Methane storage change [pmol/step]')
    plt.plot(timegrid, 1e9*generation_sums, label='Generation [pmol/step]')
    plt.plot(timegrid, 1e9*meth_oxidation_sums, label='Oxidation [pmol/step]')
    plt.plot(timegrid, 1e9*surfaceflux_sums, label='Boundary flux [pmol/step]')
    plt.legend()
    plt.xlabel('Time [s]')
    plt.subplot(2, 2, 2)
    plt.plot(timegrid, 1e6*amount_change - 1e6*(generation_sums + meth_oxidation_sums + surfaceflux_sums))# + loss_in_diff))
    plt.title('Mass balance')
    plt.xlabel('Time [s]')
    plt.subplot(2, 2, 3)
    plt.plot(timegrid, 1e9*loss_in_diff)
    plt.title('Boundary flux')
    plt.xlabel('Time [s]')
    plt.subplot(2, 2, 4)
    plt.plot(timegrid, 1e6*amount, label='Methane storage [nmol]')
    plt.plot(timegrid, 1e6*np.cumsum(generation_sums), label='Cumulative generation [nmol]')
    plt.plot(timegrid, 1e6*np.cumsum(meth_oxidation_sums), label='Cumulative oxidation [nmol]')
    plt.plot(timegrid, 1e6*np.cumsum(surfaceflux_sums), label='Cumulative boundary flux [nmol]')
    plt.legend()
    plt.xlabel('Time [s]')
    plt.tight_layout()

    #--------------------------------------------------------------------------

    plt.figure(num=5,figsize=[11, 6])
    plt.clf()
    plt.subplot(2, 2, 1)
    plt.plot(timegrid, 1000*amount_change_co2, label ='CO2 storage change in the system [nmol/step]')
    #plt.plot(timegrid, 1000*co2_source_oxidation_sums, label='CO2 source from oxid [nmol/step]')
    plt.plot(timegrid, 1000*co2_source_respiration_sums, label='CO2 source from resp [nmol/step]')
    #plt.plot(timegrid, 1000*co2_source_anaer_respiration_sums, label='CO2 source from anaer resp [nmol/step]')
    plt.plot(timegrid, 1000*surfaceflux_sums_co2, label='Boundary flux CO2 [nmol/step]')
    plt.legend()
    plt.xlabel('Time [s]')
    plt.subplot(2, 2, 2)
    plt.plot(timegrid, amount_change_co2 - (co2_source_respiration_sums
             + surfaceflux_sums_co2))# + loss_in_diff_co2))
    plt.title('Mass balance')
    plt.xlabel('Time [s]')
    plt.subplot(2, 2, 3)
    plt.plot(timegrid, 1000*loss_in_diff_co2)
    plt.title('Boundary flux')
    plt.xlabel('Time [s]')
    plt.subplot(2, 2, 4)
    plt.plot(timegrid, amount_co2, label='CO2 storage in the system [mmol]')
    #plt.plot(timegrid, np.cumsum(co2_source_oxidation_sums), label='Cumulative oxid source [mmol]')
    plt.plot(timegrid, np.cumsum(co2_source_respiration_sums), label='Cumulative resp source [mmol]')
    #plt.plot(timegrid, np.cumsum(co2_source_anaer_respiration_sums), label='Cumulative anaer degr source [mmol]')
    plt.plot(timegrid, np.cumsum(surfaceflux_sums_co2), label='Cumulative boundary flux [mmol]')
    plt.legend()
    plt.xlabel('Time [s]')
    plt.tight_layout()
    
    plt.figure(num=6,figsize=[11, 6])
    plt.clf()
    plt.subplot(2, 2, 1)
    plt.plot(timegrid, 1000*amount_change_o2, label ='O2 storage change in the system [nmol/step]')
    plt.plot(timegrid, 1000*o2_sink_oxidation_sums, label='O2 sink from oxid [nmol/step]')
    plt.plot(timegrid, 1000*o2_sink_respiration_sums, label='O2 sink from resp [nmol/step]')
    plt.plot(timegrid, 1000*surfaceflux_sums_o2, label='Boundary flux O2 [nmol/step]')
    plt.legend()
    plt.xlabel('Time [s]')
    plt.subplot(2, 2, 2)
    plt.plot(timegrid, amount_change_o2 - (o2_sink_oxidation_sums + o2_sink_respiration13_sums
                + o2_sink_respiration_sums + surfaceflux_sums_o2))
    plt.title('Mass balance')
    plt.xlabel('Time [s]')
    plt.subplot(2, 2, 3)
    plt.plot(timegrid, 1000*loss_in_diff_o2)
    plt.title('Boundary flux')
    plt.xlabel('Time [s]')
    plt.subplot(2, 2, 4)
    plt.plot(timegrid, amount_o2, label='O2 storage in the system [mmol]')
    plt.plot(timegrid, np.cumsum(o2_sink_oxidation_sums), label='Cumulative oxid sink [mmol]')
    plt.plot(timegrid, np.cumsum(o2_sink_respiration_sums), label='Cumulative resp sink [mmol]')
    plt.plot(timegrid, np.cumsum(surfaceflux_sums_o2), label='Cumulative boundary flux [mmol]')
    plt.legend()
    plt.xlabel('Time [s]')
    plt.tight_layout()
    
    plt.figure(num=55,figsize=[11, 6])
    plt.clf()
    plt.subplot(2, 2, 1)
    plt.plot(timegrid, 1000*1000*amount_change_co13, label ='13-CO2 storage change in the system [pmol/step]')
    plt.plot(timegrid, 1000*1000*co2_source_oxidation_sums, label='13-CO2 source from oxid [pmol/step]')
    plt.plot(timegrid, 1000*1000*co13_source_respiration_sums, label='13-CO2 source from resp [pmol/step]')
    plt.plot(timegrid, 1000*1000*co2_source_anaer_respiration_sums, label='13-CO2 source from anaer resp [pmol/step]')
    plt.plot(timegrid, 1000*1000*surfaceflux_sums_co13, label='Boundary flux 13-CO2 [pmol/step]')
    plt.legend()
    plt.xlabel('Time [s]')
    plt.subplot(2, 2, 2)
    plt.plot(timegrid, amount_change_co13 - (co2_source_oxidation_sums + co13_source_respiration_sums + co2_source_anaer_respiration_sums
             + surfaceflux_sums_co13))# + loss_in_diff_co2))
    plt.title('Mass balance')
    plt.xlabel('Time [s]')
    plt.subplot(2, 2, 3)
    plt.plot(timegrid, 1000*1000*loss_in_diff_co13)
    plt.title('Boundary flux')
    plt.xlabel('Time [s]')
    plt.subplot(2, 2, 4)
    plt.plot(timegrid, 1000*amount_co13, label='CO13 storage in the system [mumol]')
    plt.plot(timegrid, 1000*np.cumsum(co2_source_oxidation_sums), label='Cumulative oxid source [mumol]')
    plt.plot(timegrid, 1000*np.cumsum(co13_source_respiration_sums), label='Cumulative resp source [mumol]')
    plt.plot(timegrid, 1000*np.cumsum(co2_source_anaer_respiration_sums), label='Cumulative anaer degr source [mumol]')
    plt.plot(timegrid, 1000*np.cumsum(surfaceflux_sums_co13), label='Cumulative boundary flux [mumol]')
    plt.legend()
    plt.xlabel('Time [s]')
    plt.tight_layout()
    
    def draw_3D_prof(target, c, numm, tit):
        
        fig18 = plt.figure(numm)
        plt.clf()
        ax = fig18.gca(projection='3d')
        cqwer = ax.scatter(target['pore.coords'][:,0], target['pore.coords'][:,1], target['pore.coords'][:,2], c=c, cmap=plt.cm.RdYlGn)
        fig18.colorbar(cqwer)
        plt.title(str(tit))
    
    draw_3D_prof(pn,conc_2, 3,'Methane concentration')
    draw_3D_prof(pn,conc_2_co2, 33,'CO2 concentration')
    draw_3D_prof(pn,conc_2_o2, 333,'O2 concentration')
    draw_3D_prof(pn,conc_2_co13, 3333,'13-CO2 concentration')
    
    draw_3D_prof(pn,co2_source_respiration/vols, 44,'Oxic respiration')
    draw_3D_prof(pn,phys_o2['pore.resp_restr_factor'], 45,'pore.resp_restr_factor')
    
    
    #Calculation of the conservation of oxygen and carbon atoms in the simulation
    #final == init + flux => init == final - flux
    
    c_tot_init = np.sum((air['pore.concentration_init'] + co2['pore.concentration_init'])*vols)
    
    o_tot_init = np.sum((2 * co2['pore.concentration_init'] + 2 * o2['pore.concentration_init'])*vols)
    
    c_tot_final = (np.sum((air['pore.concentration'] + co2['pore.concentration']+co13['pore.concentration'])*vols)
                  - (np.sum(surfaceflux_sums_co2) + np.sum(surfaceflux_sums_co13) + np.sum(surfaceflux_sums)
                     + np.sum(degrading_carbons)))
    
    o_tot_final = (np.sum((2 * co2['pore.concentration'] + 2 * co13['pore.concentration'] + 2 * o2['pore.concentration'])*vols)
                  - (2 * np.sum(surfaceflux_sums_o2) + 2 * np.sum(surfaceflux_sums_co2) + + 2 * np.sum(surfaceflux_sums_co13)
                     + 2*np.sum(co2_source_anaer_respiration_sums) - np.sum(h2o_source_oxidation_sums)) )
    
    if not np.allclose(o_tot_final,o_tot_init):
        print('Oxygen is not conserved!')
    
    if not np.allclose(c_tot_final,c_tot_init):
        print('Carbon is not conserved!')
    
    plt.figure(num=7,figsize=[6, 8])
    plt.clf()
    plt.subplot(3, 1, 1)
    surf_area = np.pi/4*np.max(pn['pore.coords'][:,1])**2
    height = np.max(pn['pore.coords'][:,0])
    rho_c = 60000 # g C / m3 in peat (bulk density 120 kg m-3, C mass ratio 0.5)
    plt.plot(timegrid, 0.001 *(60*60)*12.01*surfaceflux_sums_co2/stept/surf_area, label='CO2 surface flux (g C m-2 h-1)')
    plt.legend() # g/mg * s/h * mg/mmol * mmol * s-1 * m-2
    plt.subplot(3, 1, 2)
    plt.plot(timegrid, 1000*surfaceflux_sums_co2/stept/surf_area, label='CO2 surface flux (mumol CO2 m-2 s-1)')
    plt.legend() # mumol/mol * mmol * s-1 * m-2
    plt.subplot(3, 1, 3)
    plt.plot(timegrid, (60*60)*1000*surfaceflux_sums_co2/stept/surf_area/height/rho_c, label='CO2 surface flux (mumol CO2 (g C)-1 h-1)')
    plt.legend() # s/h * mumol/mol * mmol * s-1 * m-3 * m3/ g
    plt.tight_layout()
    
    plt.figure(num=8,figsize=[6, 8])
    plt.clf()
    plt.subplot(3, 1, 1)
    surf_area = np.pi/4*np.max(pn['pore.coords'][:,1])**2
    plt.plot(timegrid, 0.001 *(60*60)*12.01*surfaceflux_sums/stept/surf_area, label='CH4 surface flux (g C m-2 h-1)')
    plt.legend() # g/mg * s/h * mg/mmol * mmol * s-1 * m-2
    plt.subplot(3, 1, 2)
    plt.plot(timegrid, 1000*1000*surfaceflux_sums/stept/surf_area, label='CH4 surface flux (nmol CH4 m-2 s-1)')
    plt.legend() # nmol/mol * mmol * s-1 * m-2
    plt.subplot(3, 1, 3)
    plt.plot(timegrid, (60*60)*1000*1000*surfaceflux_sums/stept/surf_area/height/rho_c, label='CH4 surface flux (nmol CH4 (g C)-1 h-1)')
    plt.legend() # s/h * nmol/mol * mmol * s-1 * m-3 * m3/ g
    plt.tight_layout()
    
    
    if True:
        # Vertical 1D presentation of concentrations and other things at the final state
        fig = plt.figure(10)
        plt.clf()
        fig.set_size_inches([8,5])
        plt.subplot(3,1,1)
        plt.scatter(pn['pore.coords'][:,0],1000*air['pore.concentration'],s=6)
        plt.title('CH4 concentration')
        plt.subplot(3,1,2)
        plt.scatter(pn['pore.coords'][:,0],co2['pore.concentration'],s=6)
        plt.title('CO2 concentration')
        plt.subplot(3,1,3)
        plt.scatter(pn['pore.coords'][:,0],o2['pore.concentration'],s=6)
        plt.title('O2 concentration')
        plt.tight_layout()
        
        fig = plt.figure(11)
        plt.clf()
        fig.set_size_inches([8,5])
        plt.subplot(4,1,1)
        Ps_int = pn['pore.internal']
        dmmy = co2_source_oxidation[Ps_int]/vols[Ps_int]#[-1,:]
        plt.scatter(pn['pore.coords'][Ps_int,0],dmmy,s=6)
        if np.max(np.abs(dmmy)) > 0:
            plt.ylim([np.min(dmmy)-0.1*np.max(dmmy),1.1*np.max(dmmy)])
        plt.grid()
        plt.title('CO2 gain through oxidation')
        plt.subplot(4,1,2)
        dmmy = co2_source_respiration[Ps_int]/vols[Ps_int]#[-1,:]
        plt.scatter(pn['pore.coords'][Ps_int,0],dmmy,s=6)
        if np.max(np.abs(dmmy)) > 0:
            plt.ylim([np.min(dmmy)-0.1*np.max(dmmy),1.1*np.max(dmmy)])
        plt.grid()
        plt.title('CO2 gain through respiration')
        plt.subplot(4,1,3)
        dmmy = co2_source_anaer_respiration[Ps_int]/vols[Ps_int]#[-1,:]
        plt.scatter(pn['pore.coords'][Ps_int,0],dmmy,s=6)
        if np.max(np.abs(dmmy)) > 0:
            plt.ylim([np.min(dmmy)-0.1*np.max(dmmy),1.1*np.max(dmmy)])
        plt.grid()
        plt.title('CO2 gain through anaerobic respiration')
        plt.subplot(4,1,4)
        dmmy = generation/vols_source#[-1,:]
        plt.scatter(pn['pore.coords'][Ps_middle_meth,0],dmmy,s=6)
        plt.ylim([np.min(dmmy)-0.01*np.max(dmmy),1.01*np.max(dmmy)])
        plt.grid()
        plt.title('Methanogenesis')
        plt.tight_layout()
        
        fig = plt.figure(12)
        plt.clf()
        fig.set_size_inches([8,4])
        plt.subplot(3,1,1)
        dmmy = o2_sink_oxidation[Ps_int]/vols[Ps_int]#[-1,:]
        plt.scatter(pn['pore.coords'][Ps_int,0],dmmy,s=6)
        if np.max(np.abs(dmmy)) > 0:
            plt.ylim([np.min(dmmy)-0.1*np.max(dmmy),1.1*np.max(dmmy)])
        plt.grid()
        plt.title('O2 loss through oxidation')
        plt.subplot(3,1,2)
        dmmy = o2_sink_respiration[Ps_int]/vols[Ps_int]#[-1,:]
        plt.scatter(pn['pore.coords'][Ps_int,0],dmmy,s=6)
        if np.max(np.abs(dmmy)) > 0:
            plt.ylim([np.min(dmmy)-0.1*np.max(dmmy),1.1*np.max(dmmy)])
        plt.grid()
        plt.title('O2 loss through respiration')
        plt.subplot(3,1,3)
        dmmy = meth_oxidation[Ps_int]/vols[Ps_int]#[-1,:]
        plt.scatter(pn['pore.coords'][Ps_int,0],dmmy,s=6)
        if np.max(np.abs(dmmy)) > 0:
            plt.ylim([np.min(dmmy)-0.1*np.max(dmmy),1.1*np.max(dmmy)])
        plt.grid()
        plt.title('Methane loss through oxidation')
        plt.tight_layout()
        
        #Evolution of amounts and mole fractions of the gases in the headspace
        
        fig = plt.figure(15)
        plt.clf()
        fig.set_size_inches([8,7])
        plt.subplot(3,2,1)
        plt.plot(timegrid, 1e6*n_meth_exts, label='CH4 (nmol)')
        plt.title('External CH4 amount (nmol)')
        plt.subplot(3,2,2)
        plt.plot(timegrid, n_co2_exts, label='CO2 (mmol)')
        plt.title('External CO2 amount (mmol)')
        plt.subplot(3,2,3)
        plt.plot(timegrid, n_o2_exts, label='O2 (mmol)')
        plt.title('External O2 amount (mmol)')
        plt.subplot(3,2,4)
        plt.plot(timegrid, n_co13_exts, label='13-CO2 (mmol)')
        plt.title('External 13-CO2 amount (mmol)')
        plt.subplot(3,2,5)
        plt.plot(timegrid, 1e3*n_acets, label='Acetate (mumol)')
        plt.title('Source amount (mumol)')
        plt.subplot(3,2,6)
        plt.plot(timegrid, n_co13_exts/(n_co2_exts+n_co13_exts), label='13-CO2 / CO2 ')
        plt.title('External 13-CO2 fraction (mmol/mmol)')
        plt.tight_layout()
        
        ntp = 41600
        
        fig = plt.figure(150)
        plt.clf()
        fig.set_size_inches([8,7])
        plt.subplot(3,2,1)
        plt.plot(timegrid, 1e9*n_meth_exts/V_ext/ntp, label='CH4 (nmol)')
        plt.title('External CH4 mole fraction (ppb)')
        plt.subplot(3,2,2)
        plt.plot(timegrid, 1e6*(n_co2_exts+n_co13_exts)/V_ext/ntp, label='CO2 (mmol)')
        plt.title('External CO2 mole fraction (ppm)')
        plt.subplot(3,2,3)
        plt.plot(timegrid, n_o2_exts/V_ext/ntp, label='O2 (mmol)')
        plt.title('External O2 mole fraction')
        plt.subplot(3,2,4)
        plt.plot(timegrid, 1e6*n_co13_exts/V_ext/ntp, label='13-CO2 (mmol)')
        plt.title('External 13-CO2 mole fraction (ppm)')
        plt.subplot(3,2,5)
        plt.plot(timegrid, 1e3*n_acets, label='Acetate (mumol)')
        plt.title('Source amount (mumol)')
        plt.subplot(3,2,6)
        plt.plot(timegrid, n_co13_exts/(n_co2_exts+n_co13_exts), label='13-CO2 / CO2 ')
        plt.title('External 13-CO2 fraction (mmol/mmol)')
        plt.tight_layout()
        
        fig = plt.figure(16)
        plt.clf()
        fig.set_size_inches([4,4])
        plt.subplot(1,1,1)
        plt.plot(timegrid,1000*o2_sink_respiration_sums/vol_sample/stept)
        plt.title('Bulk heterotrophic respiration mumol O2 m-3 s-1')
        plt.tight_layout()
        
    #--------------------------------------------------------------------------
